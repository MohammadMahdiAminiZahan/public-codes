from collections import deque, defaultdict

class Environment:
    def __init__(self, world):
        self.world = world
        self.height = len(world)
        self.width = len(world[0]) if self.height > 0 else 0

    def neighbors(self, x, y):
        candidates = [(x-1,y), (x+1,y), (x,y-1), (x,y+1)]
        return [(nx, ny) for (nx, ny) in candidates if 0 <= nx < self.width and 0 <= ny < self.height]

    def get_percepts(self, x, y):
        # هر خانه می‌تونه رشته‌ای شامل علامت‌ها مثل "B", "S", "P", "W", "G" یا ترکیبی باشه
        return self.world[y][x]

    def all_cells(self):
        return [(x,y) for y in range(self.height) for x in range(self.width)]


class ProbabilisticAgent:
    def __init__(self, env, risk_threshold=0.01):
        self.env = env
        self.start = (0, env.height - 1)  # شروع از پایین چپ
        self.current = self.start
        self.visited = set()
        self.safe = set([self.start])
        self.frontier = set()
        self.percepts = {}
        self.pit_prob = defaultdict(lambda: 0.0)
        self.wumpus_prob = defaultdict(lambda: 0.0)
        self.confirmed_pits = set()
        self.confirmed_wumpus = None
        self.path = [self.start]
        self.gold_found = False
        self.risk_threshold = risk_threshold

    def get_adjacent(self, x, y):
        return self.env.neighbors(x, y)

    def record_percepts(self, cell):
        percept = self.env.get_percepts(*cell)
        self.percepts[cell] = percept
        return percept

    def update_probabilities(self):
        for cell in self.env.all_cells():
            if cell in self.safe or cell in self.confirmed_pits or cell == self.confirmed_wumpus:
                continue
            pit_p = 0.0
            wumpus_p = 0.0
            adj = self.get_adjacent(*cell)
            breeze_sources = [c for c in adj if 'B' in self.percepts.get(c, '')]
            if breeze_sources:
                pit_p = 1 - (0.5 ** len(breeze_sources))
            else:
                pit_p = 0.0

            stench_sources = [c for c in adj if 'S' in self.percepts.get(c, '')]
            if stench_sources:
                wumpus_p = 1 - (0.5 ** len(stench_sources))
            else:
                wumpus_p = 0.0

            self.pit_prob[cell] = pit_p
            self.wumpus_prob[cell] = wumpus_p

        for cell in list(self.pit_prob.keys()):
            if self.pit_prob[cell] > 0.95:
                self.confirmed_pits.add(cell)
                if cell in self.safe:
                    self.safe.remove(cell)

        wumpus_candidates = [c for c,p in self.wumpus_prob.items() if p > 0.95]
        if len(wumpus_candidates) == 1:
            self.confirmed_wumpus = wumpus_candidates[0]
            if self.confirmed_wumpus in self.safe:
                self.safe.remove(self.confirmed_wumpus)

    def mark_safe_cells(self):
        for cell in self.env.all_cells():
            if cell in self.visited or cell in self.confirmed_pits or cell == self.confirmed_wumpus:
                continue
            if self.pit_prob[cell] < self.risk_threshold and self.wumpus_prob[cell] < self.risk_threshold:
                self.safe.add(cell)

    def update_frontier(self):
        for cell in self.visited:
            for n in self.get_adjacent(*cell):
                if n not in self.visited and n not in self.safe and n not in self.confirmed_pits and n != self.confirmed_wumpus:
                    self.frontier.add(n)

    def get_path_to(self, target):
        queue = deque([(self.current, [self.current])])
        visited = set()
        while queue:
            (x, y), path = queue.popleft()
            if (x, y) == target:
                return path
            for nx, ny in self.env.neighbors(x, y):
                if (nx, ny) not in visited and (nx, ny) in self.safe:
                    visited.add((nx, ny))
                    queue.append(((nx, ny), path + [(nx, ny)]))
        return []

    def explore(self):
        while True:
            x, y = self.current
            self.visited.add((x, y))
            percept = self.record_percepts((x, y))

            if 'P' in percept or 'W' in percept:
                return f"Khatar! Mordan dar khaneh {self.current} ba {percept}"

            if 'G' in percept:
                self.gold_found = True
                return f"Gold peyda shod dar {self.current}! Masir: {self.path}"

            self.update_probabilities()
            self.mark_safe_cells()
            self.update_frontier()

            next_steps = [cell for cell in self.safe if cell not in self.visited]
            if not next_steps:
                return "Blocked! Hich masir e amni baraye edameh nist."

            moved = False
            for cell in sorted(next_steps):
                path = self.get_path_to(cell)
                if path:
                    self.path.extend(path[1:])
                    self.current = cell
                    moved = True
                    break
            if not moved:
                return "Blocked! Hich masir e amni baraye edameh nist."


# تعریف جهان نمونه (۴x۴)
world = [
    ['B', 'B', '', 'G'],
    ['P', 'B', 'S', ''],
    ['B', 'SB', 'S', 'S'],
    ['', 'S', 'W', 'S']
]

env = Environment(world)
agent = ProbabilisticAgent(env, risk_threshold=0.01)
result = agent.explore()
print(result)
print("Masir:", agent.path)